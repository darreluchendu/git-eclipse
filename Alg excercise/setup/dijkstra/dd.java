

	I first created three new classes called \textit{Graph}, \textit{\textit{AdjListNode}} and \textit{Vertex}. \textit{AdjListNode} acts like and Edge class and stores the weight of the edge from one vertex to another and while also storing the index of the associated vertex. The \textit{Vertex} class now stores a its adjacency list,its  index, its predecessor and its distance.The adjacency list is stored as a \textit{Linked\textit{HashSet}} of \textit{AdjListNode}s. I chose to use a Linked Hash Set because it allows for fast iteration and inserts in constant time. The \textit{Graph} class is where Dijkstra's algorithm is implemented.  I store the vertices in an \textit{ArrayList} because it allow for fast random access in constant time. The Dijkstra method takes the start and end nodes as arguments.In the Dijkstra method I then created a \textit{HashSet} and a \textit{PriorityQueue} to hold the settled and unsettled nodes respectively. I used a \textit{HashSet} for settled vertices because they insert in constant time. I used a \textit{PriorityQueue} for unsettled vertices because they carry out insertions and deletions in O(log(n)) time. I added a \textit{Comparator} to the queue so that the vertices were always sorted using their distance properties. I then added the start vertex to the unsettled list and began the algorithm. Firstly I set the distance for all vertices apart form the start vertex to infinity. Then, while there were still nodes in my unsettled list, I would dequeue the priority queue. This would return the vertex with the smallest distance. I would the add that to the settled list and check if its the end node. If it is then i return the distance and path, otherwise I continue my loop. I then loop through the neighbours  of the node I just added to the settled list. If they rare not already settled then I perform relaxation by getting the minimum between their current distance property and and the distance between the neighbour and the start using the shortest distances in the settled vertices list. if the new distance is smaller, I then add the neighbour to unsettled nodes  and set its predecessor to the previous node. The loop starts again by finding the vertex with the smallest distance property in unsettled nodes and add it to settled. The algorithm would end when the smallest node in unsettled list is the end node. If it is then I return the distance and path.



	\subsection*{Backtrack Search}

	I first created three new classes called \textit{Graph}, \textit{AdjListNode} and \textit{Vertex} and Path. \textit{AdjListNode} acts like and Edge class and stores the weight of the edge from one vertex to another and while also storing the index of the associated vertex. The \textit{Vertex} class now stores a its adjacency list,its  index, its predecessor and its distance.The adjacency list is stored as a \textit{Linked\textit{HashSet}} of \textit{AdjListNode}s. I chose to use a Linked Hash Set because it allows for fast iteration and inserts in constant time. The Path class stores path of \textit{AdjListNode}s as a Stack and then the total distance of that path. I used a Stack because I will constantly be adding and removing the last added element and so a Stack would be perfect for the job seeing as it carries out both insertion and deletion in constant time. I also implemented an addToPath push a new vertex to the stack and the adds its weight to the current path method that  The \textit{Graph} class is where the backtrack algorithm is implemented.  I store the vertices in an \textit{ArrayList} because it allow for fast random access in constant time.The backtrack method takes the start and end nodes as arguments. I then create two Path objects \textit{bestPath} and \textit{currentPath}. I added the start vertex to \textit{currentPath}, set its visited property to true and then begin my recursive function.The function takes peeks at the next vertex in the Stack and the iterates through its neighbours adding them to the current path.  Each time a new vertex is added to the current path, a check is made to see whether the new path length is less than the length of \textit{bestPath} found so far; if so we continue to extend this path, but if
	not, that new vertex is rejected and the next possibility is tried instead. If the end vertex is reached with a path that has length shorter than any seen previously, the current path is recorded. When all possibilities for the current vertex have been tried, the algorithm backtracks by popping the \textit{currentPath} and the visited property for the popped vertex to false. The program then goes to the previous position in \textit{currentPath} and continues from continues there. Once all possibilities have been explored, the search is complete and \textit{bestPath} is returned. 

	\section*{Empirical results}

	This section is part of the marking scheme "Outputs from test data: 2 marks".

	Give the running times of your two programs on the data sets provided. If the program fails to terminate in, say, two minutes, then simply report non-termination. 

